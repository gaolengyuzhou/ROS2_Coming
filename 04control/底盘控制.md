# wifi
```c
// åˆå§‹åŒ–ä¸²å£
Serial.begin(115200);

// è®¾ç½® micro-ROS é€šä¿¡å‚æ•°ï¼Œè¿æ¥åˆ°æŒ‡å®šçš„ ROS2 ä»£ç†
// è¿æ¥WiFi
WiFi.begin("glyz", "85856666");
while (WiFi.status()!= WL_CONNECTED) {
delay(1000);
Serial.println("Connecting to WiFi...");
}
Serial.println("Connected to the WiFi network");

IPAddress agent_ip;
agent_ip.fromString("192.168.125.184");
set_microros_wifi_transports("glyz", "85856666", agent_ip, 8888);
delay(2000);
```
# ç”µæœºæ§åˆ¶è„‰å®½è°ƒåˆ¶å™¨
MCPWMä¸­æ–‡åæ˜¯ç”µæœºæ§åˆ¶è„‰å®½è°ƒåˆ¶å™¨ ï¼ˆMotor Control Pulse Width Modulator ï¼‰ï¼Œæ˜¯ä¸€æ¬¾å¤šåŠŸèƒ½ PWM å‘ç”Ÿå™¨


```c++
/*ç”µæœºåˆå§‹åŒ–*/
motor.attachMotor(0, 23, 22); // å°†ç”µæœº0è¿æ¥åˆ°å¼•è„š23å’Œå¼•è„š22
motor.attachMotor(1, 12, 13); // å°†ç”µæœº1è¿æ¥åˆ°å¼•è„š12å’Œå¼•è„š13

motor.updateMotorSpeed(0, -70); // è®¾ç½®ç”µæœº0çš„é€Ÿåº¦(å ç©ºæ¯”)ä¸ºè´Ÿ70%
motor.updateMotorSpeed(1, 70); // è®¾ç½®ç”µæœº1çš„é€Ÿåº¦(å ç©ºæ¯”)ä¸ºæ­£70%

motor.updateMotorSpeed(0, 70); // è®¾ç½®ç”µæœº0çš„é€Ÿåº¦(å ç©ºæ¯”)ä¸ºæ­£70%
motor.updateMotorSpeed(1, -70); // è®¾ç½®ç”µæœº1çš„é€Ÿåº¦(å ç©ºæ¯”)ä¸ºè´Ÿ70%
```

# è®¢é˜…ROS2 Twist
> æŒ‰ä¸‹å…¥JKL
```
sudo docker run -it --rm -v /dev:/dev -v /dev/shm:/dev/shm --privileged --net=host microros/micro-ros-agent:$ROS_DISTRO udp4 --port 8888 -v6
ros2 run teleop_twist_keyboard teleop_twist_keyboard
```
## è¿è¡Œå°ä¹Œé¾Ÿ
1. turtle_teleop_keyâ€”â€”èŠ‚ç‚¹ï¼š/teleop_turtle  è¯é¢˜ï¼š/turtle1/cmd_vel

```
ros2 run turtlesim turtle_teleop_key
Reading from keyboard
---------------------------
Use arrow keys to move the turtle.
Use G|B|V|C|D|E|R|T keys to rotate to absolute orientations. 'F' to cancel a rotation.
'Q' to quit.
```
2. teleop_twist_keyboardâ€”â€”èŠ‚ç‚¹ï¼š/teleop_twist_keyboard  è¯é¢˜ï¼š/cmd_vel

```
ros2 run teleop_twist_keyboard teleop_twist_keyboard

This node takes keypresses from the keyboard and publishes them
as Twist/TwistStamped messages. It works best with a US keyboard layout.
```

3. é”®ç›˜æ§åˆ¶å°ä¹Œé¾Ÿ
```
/*è¿è¡Œå°ä¹Œé¾Ÿ*/
ros2 run turtlesim turtlesim_node

ros2 run teleop_twist_keyboard teleop_twist_keyboard /cmd_vel:=/turtle1/cmd_vel


æˆ–ï¼šros2 run turtlesim turtle_teleop_key /turtle1/cmd_vel:=/cmd_vel
```

## Twistæ¶ˆæ¯ç±»å‹
    linearæè¿°äº†ç‰©ä½“åœ¨ä¸‰ç»´ç©ºé—´ä¸­æ²¿xã€yå’Œzè½´çš„çº¿æ€§é€Ÿåº¦ã€‚
    angularæè¿°äº†ç‰©ä½“ç»•xã€yå’Œzè½´çš„æ—‹è½¬é€Ÿåº¦ï¼Œå³è§’é€Ÿåº¦ã€‚
```
ros2 topic echo /turtle1/cmd_vel
linear:
  x: 0.5
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0
---


```


# ESP32 ç¼–ç å™¨é©±åŠ¨åº“--Esp32PcntEncoder

```c++
#include <Arduino.h>
#include <Esp32PcntEncoder.h>

Esp32PcntEncoder encoders[2]; // åˆ›å»ºä¸€ä¸ªæ•°ç»„ç”¨äºå­˜å‚¨ä¸¤ä¸ªç¼–ç å™¨

void setup()
{
  // 1.åˆå§‹åŒ–ä¸²å£
  Serial.begin(115200); // åˆå§‹åŒ–ä¸²å£é€šä¿¡ï¼Œè®¾ç½®é€šä¿¡é€Ÿç‡ä¸º115200

  // 2.è®¾ç½®ç¼–ç å™¨
  encoders[0].init(0, 32, 33); // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªç¼–ç å™¨ï¼Œä½¿ç”¨GPIO 32å’Œ33è¿æ¥
  encoders[1].init(1, 26, 25); // åˆå§‹åŒ–ç¬¬äºŒä¸ªç¼–ç å™¨ï¼Œä½¿ç”¨GPIO 26å’Œ25è¿æ¥
}

void loop()
{
  delay(10); // ç­‰å¾…10æ¯«ç§’

  // è¯»å–å¹¶æ‰“å°ä¸¤ä¸ªç¼–ç å™¨çš„è®¡æ•°å™¨æ•°å€¼
  Serial.printf("tick1=%d,tick2=%d\n", encoders[0].getTicks(), encoders[1].getTicks());
}
```
# é€Ÿåº¦-PID
> ç›´è§‚çš„è®²ï¼Œå°±æ˜¯ä¸ç®¡çˆ¬å¡è¿˜æ˜¯ä¸‹å¡é€Ÿåº¦éƒ½ä¸å˜ã€‚
```
å‚æ•°æ•´å®šæ‰¾æœ€ä½³ï¼Œä»å°åˆ°å¤§é¡ºåºæŸ¥ï¼› å…ˆæ˜¯æ¯”ä¾‹åç§¯åˆ†ï¼Œæœ€åå†æŠŠå¾®åˆ†åŠ ï¼› æ›²çº¿æŒ¯è¡å¾ˆé¢‘ç¹ï¼Œæ¯”ä¾‹åº¦ç›˜è¦æ”¾å¤§ï¼› æ›²çº¿æ¼‚æµ®ç»•å¤§æ¹¾ï¼Œæ¯”ä¾‹åº¦ç›˜å¾€å°æ‰³ï¼› æ›²çº¿åç¦»å›å¤æ…¢ï¼Œç§¯åˆ†æ—¶é—´å¾€ä¸‹é™ï¼› æ›²çº¿æ³¢åŠ¨å‘¨æœŸé•¿ï¼Œç§¯åˆ†æ—¶é—´å†åŠ é•¿ï¼› æ›²çº¿æŒ¯è¡é¢‘ç‡å¿«ï¼Œå…ˆæŠŠå¾®åˆ†é™ä¸‹æ¥ï¼› åŠ¨å·®å¤§æ¥æ³¢åŠ¨æ…¢ã€‚å¾®åˆ†æ—¶é—´åº”åŠ é•¿ï¼› ç†æƒ³æ›²çº¿ä¸¤ä¸ªæ³¢ï¼Œå‰é«˜åä½å››æ¯”ä¸€ï¼› ä¸€çœ‹äºŒè°ƒå¤šåˆ†æï¼Œè°ƒèŠ‚è´¨é‡ä¸ä¼šä½ï¼›
```
# ä¸¤è½®å·®é€Ÿæœºå™¨äººè¿åŠ¨å­¦Kinematics
> é€šè¿‡æœºå™¨äººçš„è¿åŠ¨å­¦é€†è§£å®Œæˆäº†æœºå™¨äººå®æ—¶çš„è§’é€Ÿåº¦å’Œçº¿é€Ÿåº¦çš„æµ‹é‡
> ä¹‹å‰é€Ÿåº¦éƒ½æ˜¯70,ç°åœ¨æœ‰äº†çœŸæ­£æ„ä¹‰çš„`cmd_vel`æ§åˆ¶
```
void twist_callback(const void *msg_in)
{
  const geometry_msgs__msg__Twist *twist_msg = (const geometry_msgs__msg__Twist *)msg_in;
  static float target_motor_speed1, target_motor_speed2;
  float linear_x = twist_msg->linear.x;   // è·å– Twist æ¶ˆæ¯çš„çº¿æ€§ x åˆ†é‡
  float angular_z = twist_msg->angular.z; // è·å– Twist æ¶ˆæ¯çš„è§’åº¦ z åˆ†é‡
  kinematics.kinematic_inverse(linear_x * 1000, angular_z, target_motor_speed1, target_motor_speed2);
  pid_controller[0].update_target(target_motor_speed1);
  pid_controller[1].update_target(target_motor_speed2);
}
```

# -----------------------ğŸ˜³ğŸ˜³ğŸ˜³------------------------------
# é‡Œç¨‹è®¡ç§¯åˆ†
```c++
void loop()
{
  static float out_motor_speed[2];
  static uint64_t last_update_info_time = millis();
  kinematics.update_motor_ticks(micros(), encoders[0].getTicks(), encoders[1].getTicks());
  out_motor_speed[0] = pid_controller[0].update(kinematics.motor_speed(0));
  out_motor_speed[1] = pid_controller[1].update(kinematics.motor_speed(1));
  motor.updateMotorSpeed(0, out_motor_speed[0]);
  motor.updateMotorSpeed(1, out_motor_speed[1]);

  unsigned long currentMillis = millis(); // è·å–å½“å‰æ—¶é—´
  if (currentMillis - previousMillis >= interval)
  {                                 // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾é—´éš”æ—¶é—´
    previousMillis = currentMillis; // è®°å½•ä¸Šä¸€æ¬¡æ‰“å°çš„æ—¶é—´
    float linear_speed, angle_speed;
    kinematics.kinematic_forward(kinematics.motor_speed(0), kinematics.motor_speed(1), linear_speed, angle_speed);
    Serial.printf("[%ld] linear:%f angle:%f\n", currentMillis, linear_speed, angle_speed);                       // æ‰“å°å½“å‰æ—¶é—´
    Serial.printf("[%ld] x:%f y:%f yaml:%f\n", currentMillis,kinematics.odom().x, kinematics.odom().y, kinematics.odom().yaw); // æ‰“å°å½“å‰æ—¶é—´
  }

  // å»¶è¿Ÿ10æ¯«ç§’
  delay(10);
}
```

```
 ros2 interface show nav_msgs/msg/Odometry 
 ```
 
 
# MicroROSå‘å¸ƒé‡Œç¨‹è®¡
â€µâ€µ`
nav_msgs/msg/Odometry
â€µâ€µ`
